<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/Guava EventBus 源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/Guava EventBus 源码解析/" itemprop="url">Unbenannt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-20T15:38:00+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="Guava-EventBus-源码解析"><a href="#Guava-EventBus-源码解析" class="headerlink" title="Guava EventBus 源码解析"></a>Guava EventBus 源码解析</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>​    偶然发现项目中使用了Guava EventBus，短短的不到十个类将pub-sub模式发挥的淋漓尽致。使用起来也非常的方便，为此本文将从源码角度分析Guava EventBus的设计思想。虽然ATA上已经有很多文章分析Guava EventBus了，但发现这些文章都比较久远，而且现在的源码实现方式已经发生了改变，所以本文重新分析了Guava21版本的EventBus实现。</p>
<h2 id="2-核心类图"><a href="#2-核心类图" class="headerlink" title="2. 核心类图"></a>2. 核心类图</h2><p>​    Guava EventBus作为pub-sub模式的践行者，无非就是完成这三个动作：</p>
<ul>
<li><p>注册/取消事件监听器（到控制器）；</p>
</li>
<li><p>（控制器）发布事件；</p>
</li>
<li><p>事件监听器根据相应的事件执行对应的动作。</p>
<p>盗用一下greenrobot的EventBus来说明整个流程，就是如下图所示：</p>
<p><img src="pic/Guava-EventBus/EventBus-Publish-Subscribe.png" alt="EventBus-Publish-Subscribe"></p>
</li>
</ul>
<p>那Guava EventBus是如何实现的呢？如下类图是去掉异常处理等无关的类之后，EventBus的所有核心组件了，可以看出其设计的非常之精巧。作为整个组件的核心-EventBus，它像主控制器一样，控制着所有的事情（所有就称其为总线？）这里说EventBus是“控制”所有事情，是因为它并不是真正的动作执行者，而只是控制其他组件去完成相应的动作。例如（1）注册/取消事件监听器是通过<strong>SubscriberRegistry</strong>组件的<code>register(...)</code>方法完成的；（2）发布事件是通过<strong>Dispatcher</strong>组件的<code>dispatch(...)</code>方法完成的。它像总线一样，让所有的消息都能够顺利的在其上运转起来。（3）事件执行是调用<strong>Subscriber</strong>组件利用反射来实现的。下面我们就要深入到细节，看看它具体是怎么实现的。</p>
<p><img src="pic/Guava-EventBus/eventbus-framework.png" alt="EventBus Framework"></p>
<h2 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3. 实现细节"></a>3. 实现细节</h2><p>​    在分析实现细节时，我们着重分析pub-sub的三个核心动作，搞清楚了这三个核心的动作，整个EventBus的核心源码也分析的差不多了。下面我们分块来讲解每步动作的实现细节。</p>
<h3 id="3-1-订阅器注册-REGISTER"><a href="#3-1-订阅器注册-REGISTER" class="headerlink" title="3.1 订阅器注册(REGISTER)"></a>3.1 订阅器注册(REGISTER)</h3><p>​    EventBus注册一个订阅器（也可以称之为监听器，毕竟EventBus代码中使用的名字是listener，下面所说的监听器和订阅者是同一个概念）是通过如下方法实现的，可见它内部是通过SubscriberRegistry的register()方法来实现的，那么下面我们看看这个方法是如何注册的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  subscribers.register(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    SubscriberRegistry的注册方法如下所示，它首先会扫描这个listener及其父类的所有带有<code>@Subscriber</code>注解的方法，然后抽取出方法的入参(有且仅有一个)作为事件类型(EventType)，方法及其类作为订阅者(Subscriber)，这样形成一键多值的结构；然后将其添加到这个事件类型的总列表中（因为其他的listener可能已经有对该事件进行监听，所以EventBus总线中记录了每个事件类型下的所有订阅者）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Object listener)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//首先查找这个监听器的所有订阅者，返回事件类型(EventType)：监听者(listener)列表这样的集合</span></span><br><span class="line">  Multimap&lt;Class&lt;?&gt;, Subscriber&gt; listenerMethods = findAllSubscribers(listener);</span><br><span class="line">  <span class="comment">//接下来就是逐个扫描每个事件类型，并且将新的listener加入到EventBus的这个事件类型列表中。</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;Subscriber&gt;&gt; entry : listenerMethods.asMap().entrySet()) &#123;</span><br><span class="line">    Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">    Collection&lt;Subscriber&gt; eventMethodsInListener = entry.getValue();</span><br><span class="line">	<span class="comment">//以前的版本是使用锁的方式，现在使用CopyOnWriteArraySet数据结构，拷贝时不加锁，更快</span></span><br><span class="line">    CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);</span><br><span class="line">	<span class="comment">//如果为空就新建一个集合，然后把新添加的listner添加进来</span></span><br><span class="line">    <span class="keyword">if</span> (eventSubscribers == <span class="keyword">null</span>) &#123;</span><br><span class="line">      CopyOnWriteArraySet&lt;Subscriber&gt; newSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;Subscriber&gt;();</span><br><span class="line">      eventSubscribers =</span><br><span class="line">          MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);</span><br><span class="line">    &#125;</span><br><span class="line">    eventSubscribers.addAll(eventMethodsInListener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在上述的代码中，我们发现解析这个监听器所订阅的事件类型，并且返回{事件类型：订阅者列表}这样的数据结构最为关键，那SubscriberRegistry是如何解析监听器的呢？我们看看他的源码，如下所示，它实际上是通过反射的方式，拿到这个监听器及其父类的所有带有<code>@Subscribe</code>的注解的方法，然后取这个方法的入参作为事件类型，这个方法的类作为订阅者，以此形成{事件类型：订阅者列表}这样的数据结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Multimap&lt;Class&lt;?&gt;, Subscriber&gt; findAllSubscribers(Object listener) &#123;</span><br><span class="line">  Multimap&lt;Class&lt;?&gt;, Subscriber&gt; methodsInListener = HashMultimap.create();</span><br><span class="line">  <span class="comment">//获取这个listener的类对象</span></span><br><span class="line">  Class&lt;?&gt; clazz = listener.getClass();</span><br><span class="line">  <span class="comment">//找出这个listener类及其父类的所有有@Subscribe注解的方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class="line">    <span class="comment">//获取带有@Subscribe注解的方法的入参(有且仅有一个)，并以此为key加入到监听列表中。</span></span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">    methodsInListener.put(eventType, Subscriber.create(bus, listener, method));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> methodsInListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这里我们有必要看看<code>getAnnotatedMethods(...)</code>方法是如何来提取listener中的事件处理逻辑的。它会扫描这个listener自己及其父类，然后找出所有带有<code>@Subscribe</code>的注解，并将其加入到集合中，需要注意的是，带有<code>@Subscribe</code>的注解的方法，有且仅有一个入参，否则就会报错。这也解释了为啥EventBus的Subscriber的方法只能有一个参数，是在这段代码中进行限制的。有必要在此多说一点，这个<code>@Subscribe</code>注解可以称之为Guava的神来之笔，一般可以采用Observer设计模式来实现这种pub-sub模型，然而这个设计模式需要定义两个接口，让用户去实现这个接口及其对应的方法；而<strong>Guava采用注解的方式来取代接口的方式来实现，这种“隐式契约”显然要比接口这种“显式契约”要松散多了</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ImmutableList&lt;Method&gt; <span class="title">getAnnotatedMethodsNotCached</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//该listener的父类可能也是一个listener，所以也要分析其父类</span></span><br><span class="line">  Set&lt;? extends Class&lt;?&gt;&gt; supertypes = TypeToken.of(clazz).getTypes().rawTypes();</span><br><span class="line">  Map&lt;MethodIdentifier, Method&gt; identifiers = Maps.newHashMap();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; supertype : supertypes) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Method method : supertype.getDeclaredMethods()) &#123;</span><br><span class="line">      <span class="comment">//判断这个方法是否有@Subscribe注解</span></span><br><span class="line">      <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class) &amp;&amp; !method.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// TODO(cgdecker): Should check for a generic parameter type and error out</span></span><br><span class="line">        <span class="comment">//而且这个方法必须只有一个入参，否则就会报错</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        checkArgument(</span><br><span class="line">            parameterTypes.length == <span class="number">1</span>,</span><br><span class="line">            <span class="string">"Method %s has @Subscribe annotation but has %s parameters."</span></span><br><span class="line">                + <span class="string">"Subscriber methods must have exactly 1 parameter."</span>,</span><br><span class="line">            method,</span><br><span class="line">            parameterTypes.length);</span><br><span class="line"></span><br><span class="line">        MethodIdentifier ident = <span class="keyword">new</span> MethodIdentifier(method);</span><br><span class="line">        <span class="keyword">if</span> (!identifiers.containsKey(ident)) &#123;</span><br><span class="line">          identifiers.put(ident, method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ImmutableList.copyOf(identifiers.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    到此为止，我们分析了一个订阅者是如何被注册到EventBus中的。简单来说，EventBus是通过<code>@Subscribe</code>注解来标识某个方法是事件的处理方法，通过方法参数类型标识事件类型。</p>
<h3 id="3-2-事件发布-POST"><a href="#3-2-事件发布-POST" class="headerlink" title="3.2 事件发布(POST)"></a>3.2 事件发布(POST)</h3><p>​    EventBus的事件发布，是通过<code>post(...)</code>函数来实现的。这个函数主要有两个动作：（1）找到这个事件的所有订阅者；（2）向这些订阅者发布该事件。下面我们来详细看看这两个动作是如何执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//找到这个事件的所有订阅者</span></span><br><span class="line">  Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(event);</span><br><span class="line">  <span class="keyword">if</span> (eventSubscribers.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//如果这个事件有相应的订阅者，则发布事件</span></span><br><span class="line">    dispatcher.dispatch(event, eventSubscribers);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</span><br><span class="line">    <span class="comment">// 否则，就发布一个DeadEvent类型的事件(这个事件含义就是没有订阅者的事件)</span></span><br><span class="line">    post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, event));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Step1: 找到这个事件的订阅者。EventBus并不是单单找到这个Event事件本身的订阅者，还找到了这个Event的所有父类及父类实现的接口的所有事件的订阅者。为什么要找这么多订阅者呢？这其实是一个见仁见智的问题。我们举个例子，设SuperEvent是Event的父类，如果Listener订阅了SuperEvent的事件，当事件Event发生时，因为Event也是一个SuperEvent，也可以认为是SuperEvent发生了，所以Event的发生也需要通知订阅了SuperEvent的Listener。所以EventBus认为A事件发生时，也应该通知所有A的父类事件。毕竟继承关系是is-a关系，这种操作我认为是合理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;Subscriber&gt; <span class="title">getSubscribers</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//扁平化这个类：目的是找到这个类、父类以及他们实现的接口</span></span><br><span class="line">  ImmutableSet&lt;Class&lt;?&gt;&gt; eventTypes = flattenHierarchy(event.getClass());</span><br><span class="line">  List&lt;Iterator&lt;Subscriber&gt;&gt; subscriberIterators =</span><br><span class="line">      Lists.newArrayListWithCapacity(eventTypes.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; eventType : eventTypes) &#123;</span><br><span class="line">    <span class="comment">//找到这个事件类型的所有订阅者，并且把它加到集合中</span></span><br><span class="line">    CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (eventSubscribers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// eager no-copy snapshot</span></span><br><span class="line">      subscriberIterators.add(eventSubscribers.iterator());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//这个大集合包含了这个event、父类以及他们所实现接口的所有类型的订阅者</span></span><br><span class="line">  <span class="keyword">return</span> Iterators.concat(subscriberIterators.iterator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Step2:向这些事件订阅者发布该事件。EventBus的事件分发器是交由Dispatcher对象来实现的。在继续分析代码之前，我们先看看Dispatcher的设计，类图如下所示：</p>
<p><img src="pic/Guava-EventBus/Dispatcher.png" alt="Dispatcher"></p>
<p>EventBus总共提供了三种分发类：</p>
<ul>
<li>PerThreadQueuedDispatcher:从名字可以看出来这个事件分发器是以线程为单位进行的，它<strong>为每个线程申请了一个队列</strong>，这个队列存放了所有投递到该线程的事件及其订阅者们，并且按照事件到达的顺序依次进行投放。</li>
<li>LegacyAsyncDispatcher:从名字来看这个事件分发器应该是要废弃掉的(官方的说法是：but is otherwise not especially useful.)，与PerThreadQueuedDispatcher相比，它是采用了一个<strong>全局队列</strong>来存储所有{到达的事件：订阅者}对，它不确保投放的顺序和事件到达的顺序是一致的。这也是作者诟病既然不能保证顺序，用队列就是多此一举。</li>
<li>ImmediateDispatcher:从名字来看这个事件分发器是立即发布当前的这个事件，实际情况也是如此，当用户调用<code>dispatch(...)</code>方法时，它不用任何队列缓存事件，而是<strong>立即向该事件的订阅者发布事件</strong>。</li>
</ul>
<p>可能这么解释不太直观，下面我们将结合源码并辅以图的形式来展示这三种事件分发器的工作原理。</p>
<blockquote>
<p>注：在如下的三幅图里，分别展示了3个线程(thread-1，thread-2，thread-3)和5个事件(E1，E2，E3，E4，E5)在不同的分发模型下的处理方式，其中事件E1到E5是按照时间顺序先后发布的。</p>
</blockquote>
<p>（1）PerThreadQueuedDispatcher</p>
<p>​    在此分发模型下，它会为每个线程申请一个事件队列，该线程所发布的事件都会存入此队列下，因此保证了线程内的事件发布顺序一致性，而且在分发过程中，按照广度优先原则：事件A的所有订阅者都处理完毕时，再发布下一个事件来进行发布。如下图所示：</p>
<p><img src="pic/Guava-EventBus/PerThreadQueuedDispatcher.png" alt="PerThreadQueuedDispatcher"></p>
<p>​    如下是该模型是实现方式。可以看到该模型有两个核心的变量：queue和dispatching。这两个变量都是绑定到线程上的，queue还比较好理解，是用来存放到达该线程的事件，<strong>那Boolean类型的dispatching线程局部变量是干什么的呢？这个变量是为了防止线程重复发布事件，即多次递归调用了<code>post(...)</code>方法</strong>。（聪明的读者请思考此情景如何出现？最后会给一个思考题）因此在第一次进入的时候，将dispatching变量置为true，下次就不会再重入进来。由此可以看出该模型保证了同一线程下事件是按序发布的，而且当一个事件的订阅者都接收到消息时，才会发布下一个事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PerThreadQueuedDispatcher</span> <span class="keyword">extends</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Per-thread queue of events to dispatch.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Queue&lt;Event&gt;&gt; queue =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Queue&lt;Event&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> Queue&lt;Event&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Queues.newArrayDeque();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Per-thread dispatch state, used to avoid reentrant event dispatching.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; dispatching =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> Boolean <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> </span>&#123;</span><br><span class="line">      checkNotNull(event);</span><br><span class="line">      checkNotNull(subscribers);</span><br><span class="line">      Queue&lt;Event&gt; queueForThread = queue.get();</span><br><span class="line">      queueForThread.offer(<span class="keyword">new</span> Event(event, subscribers));</span><br><span class="line">	<span class="comment">//防止多次重入分发逻辑，线程第一次进入时将此变量设置为true,下次无法再次进入。</span></span><br><span class="line">      <span class="keyword">if</span> (!dispatching.get()) &#123;</span><br><span class="line">        dispatching.set(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Event nextEvent;</span><br><span class="line">          <span class="comment">//事件的分发逻辑，循环取每个事件，并且向该事件的订阅者发布消息。</span></span><br><span class="line">          <span class="keyword">while</span> ((nextEvent = queueForThread.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextEvent.subscribers.hasNext()) &#123;</span><br><span class="line">              nextEvent.subscribers.next().dispatchEvent(nextEvent.event);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          dispatching.remove();</span><br><span class="line">          queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>（2）LegacyAsyncDispatcher</p>
<p>​    在此分发模型下，事件的发布顺序无法保障和事件的到达顺序一致，而且也无法保证事件是按照广度优先的策略发布的，即A事件的所有订阅者都收到消息时才发布下一个事件。如下图所示，在发布队列中可以看到事件是乱序的。</p>
<p><img src="pic/Guava-EventBus/LegacyAsyncDispatcher.png" alt="LegacyAsyncDispatcher"></p>
<p>​    源码如下所示，它是使用了全局的queue来存储所有到达的事件，将原来的{事件：订阅者列表}拆成若干个{事件：订阅者}这样的键值对，然后将其加入到全局的队列中，多个线程同时添加{事件：订阅者}到queue时，可能会出现混乱的情况，如上图的<code>E3:L5</code>键值对出现在了<code>E2:L7</code>和<code>E2:L8</code>之间，这是因为在添加时可能存在多个事件同时入队的情况，所以它也没有PerThreadQueuedDispatcher模型的广度遍历的优势。既然无法保证顺序还要使用队列，难怪作者将其命名为“Legacy”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Global event queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;EventWithSubscriber&gt; queue =</span><br><span class="line">    Queues.newConcurrentLinkedQueue();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> </span>&#123;</span><br><span class="line">  checkNotNull(event);</span><br><span class="line">  <span class="keyword">while</span> (subscribers.hasNext()) &#123;</span><br><span class="line">    queue.add(<span class="keyword">new</span> EventWithSubscriber(event, subscribers.next()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventWithSubscriber e;</span><br><span class="line">  <span class="keyword">while</span> ((e = queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.subscriber.dispatchEvent(e.event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）ImmediateDispatcher</p>
<p>​    既然LegacyAsyncDispatcher使用了队列也没有保障事件发布是顺序的，那干嘛还要使用队列？因此就有了直接分发模型，即事件一旦到达就立即发布。</p>
<p><img src="pic/Guava-EventBus/ImmediateDispatcher.png" alt="ImmediateDispatcher"></p>
<p>​    源码也比较简单，如下所示。因为没有了变量存储信息，所以它也是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> </span>&#123;</span><br><span class="line">      checkNotNull(event);</span><br><span class="line">      <span class="comment">//来一个事件就遍历所有的订阅者，将他们全部发布出去。</span></span><br><span class="line">      <span class="keyword">while</span> (subscribers.hasNext()) &#123;</span><br><span class="line">        subscribers.next().dispatchEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-事件处理-INVOKE"><a href="#3-3-事件处理-INVOKE" class="headerlink" title="3.3 事件处理(INVOKE)"></a>3.3 事件处理(INVOKE)</h3><p>紧承3.2节的事件发布，我们看到尽管有不同的发布模型，但在最后时刻都调用了如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.subscriber.dispatchEvent(e.event);</span><br></pre></td></tr></table></figure>
<p>​    这段代码就是事件处理逻辑，下面我们展开来讲。该函数的源码如下所示，可以看出它原来是将其包装成一个任务，然后交由线程池(Executor)去执行。那是否意味着事件是异步处理的呢？其实EventBus的默认Executor使用的DirectExecutor，即使用当前的线程来执行事件处理逻辑。特殊的，对于某些事件处理逻辑在并发场景下可能会出问题，因此EventBus非常贴心的给了一个<code>@AllowConcurrentEvents</code>注解来表明该方法只能同步调用，那是怎么实现的呢？实际上就是在<code>invokeSubscriberMethod(...)</code>方法内添加了一个<code>synchronized</code>关键字，以保证所有调用<code>invokeSubscriberMethod(...)</code>的方法在此都串行化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Dispatches &#123;<span class="doctag">@code</span> event&#125; to this subscriber using the proper executor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(<span class="keyword">final</span> Object event)</span> </span>&#123;</span><br><span class="line">    executor.execute(</span><br><span class="line">        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              invokeSubscriberMethod(event);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">              bus.handleSubscriberException(e.getCause(), context(event));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正处理事件的方法：可以看出来就是利用反射来执行该method而已。</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriberMethod</span><span class="params">(Object event)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method.invoke(target, checkNotNull(event));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Method rejected target/argument: "</span> + event, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Method became inaccessible: "</span> + event, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) e.getCause();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//有些方法可能需要加锁，因此也给出了一个同步调用的方案。这个方案对应的是@AllowConcurrentEvents注解。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriberMethod</span><span class="params">(Object event)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.invokeSubscriberMethod(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-思考题"><a href="#4-思考题" class="headerlink" title="4. 思考题"></a>4. 思考题</h2><p>至此我们分析完了Guava EventBus 的三个核心步骤，那么问题来了，请问如下代码会如何打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2017/12/26</span></span><br><span class="line"><span class="comment"> * copy from https://stackoverflow.com/questions/21947936/guava-eventbus-dispatching?rq=1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InitiateProcessing</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingStarted</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingResults</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingFinished</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EventBus bus = <span class="keyword">new</span> EventBus();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveStartRequest</span><span class="params">(InitiateProcessing evt)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Got processing request - starting processing"</span>);</span><br><span class="line">        bus.post(<span class="keyword">new</span> ProcessingStarted());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Generating results"</span>);</span><br><span class="line">        bus.post(<span class="keyword">new</span> ProcessingResults());</span><br><span class="line">        System.out.println(<span class="string">"Generating more results"</span>);</span><br><span class="line">        bus.post(<span class="keyword">new</span> ProcessingResults());</span><br><span class="line"></span><br><span class="line">        bus.post(<span class="keyword">new</span> ProcessingFinished());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processingStarted</span><span class="params">(ProcessingStarted evt)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Processing has started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resultsReceived</span><span class="params">(ProcessingResults evt)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"got results"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processingComplete</span><span class="params">(ProcessingFinished evt)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Processing has completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        bus.register(t);</span><br><span class="line">        bus.post(<span class="keyword">new</span> InitiateProcessing());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
